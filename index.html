<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Word & Number Sudoku Generator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5rem;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
        }

        .control-group h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 1.2rem;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
            color: #555;
        }

        select, input, textarea {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        select:focus, input:focus, textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .word-input {
            height: 45px;
            font-size: 16px;
            text-transform: uppercase;
            text-align: center;
            letter-spacing: 2px;
        }

        .mode-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .mode-btn {
            padding: 10px 15px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            border-radius: 25px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: 500;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
        }

        .action-buttons {
            display: flex;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
            justify-content: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            color: white;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea, #764ba2);
        }

        .btn-success {
            background: linear-gradient(135deg, #56ab2f, #a8e6cf);
        }

        .btn-warning {
            background: linear-gradient(135deg, #f093fb, #f5576c);
        }

        .btn-info {
            background: linear-gradient(135deg, #4facfe, #00f2fe);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }

        .puzzles-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 30px;
            margin-top: 30px;
        }

        .puzzle-card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            page-break-inside: avoid;
        }

        .puzzle-title {
            text-align: center;
            font-size: 1.8rem;
            color: #333;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .puzzle-difficulty {
            text-align: center;
            color: #666;
            margin-bottom: 15px;
            font-style: italic;
            font-size: 1.1rem;
        }

        .word-display {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
            border: 2px solid #667eea;
        }

        .target-word {
            font-size: 2rem;
            font-weight: bold;
            color: #667eea;
            letter-spacing: 3px;
            margin-bottom: 5px;
        }

        .word-meaning {
            font-size: 1.1rem;
            color: #555;
            font-style: italic;
        }

        .number-display {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 10px;
            border: 2px solid #ff6b6b;
        }

        .puzzle-grid {
            display: inline-block;
            margin: 0 auto 20px;
            border: 3px solid #000;
            background: white;
            border-collapse: separate;
        }

        .sudoku-table {
            border-collapse: collapse;
            margin: 0;
            padding: 0;
            background: white;
        }

        .sudoku-table td {
            width: 40px;
            height: 40px;
            text-align: center;
            vertical-align: middle;
            font-family: Arial, sans-serif;
            font-size: 18px;
            font-weight: bold;
            border: 1px solid #999;
            padding: 0;
            margin: 0;
            background: white;
        }

        /* 4x4 grid borders */
        .sudoku-table.grid-4x4 td:nth-child(2n) {
            border-right: 3px solid #000;
        }
        .sudoku-table.grid-4x4 tr:nth-child(2n) td {
            border-bottom: 3px solid #000;
        }

        /* 6x6 grid borders */
        .sudoku-table.grid-6x6 td:nth-child(3n) {
            border-right: 3px solid #000;
        }
        .sudoku-table.grid-6x6 tr:nth-child(2n) td {
            border-bottom: 3px solid #000;
        }

        /* 9x9 grid borders */
        .sudoku-table.grid-9x9 td:nth-child(3n) {
            border-right: 3px solid #000;
        }
        .sudoku-table.grid-9x9 tr:nth-child(3n) td {
            border-bottom: 3px solid #000;
        }

        /* Remove outer borders that get doubled */
        .sudoku-table td:last-child {
            border-right: none !important;
        }
        .sudoku-table tr:last-child td {
            border-bottom: none !important;
        }

        .given-cell {
            background: #f0f8ff !important;
            color: #000 !important;
            font-weight: bold;
        }

        .solution-cell {
            background: white !important;
            color: #ff0000 !important;
            font-weight: bold;
        }

        .empty-cell {
            background: white !important;
            color: transparent;
        }

        .letters-used, .numbers-used {
            margin-top: 15px;
            padding: 15px;
            background: #f0f8ff;
            border-radius: 8px;
            text-align: center;
        }

        .letters-used h4, .numbers-used h4 {
            margin-bottom: 10px;
            color: #333;
        }

        .letter-list, .number-list {
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
            gap: 10px;
        }

        .letter-item, .number-item {
            background: #667eea;
            color: white;
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 16px;
            min-width: 35px;
            text-align: center;
        }

        .number-item {
            background: #ff6b6b;
        }

        .export-section {
            text-align: center;
            margin: 20px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .puzzles-container {
                grid-template-columns: 1fr;
            }

            .sudoku-table td {
                width: 30px;
                height: 30px;
                font-size: 14px;
            }

            .controls {
                grid-template-columns: 1fr;
            }

            .target-word {
                font-size: 1.5rem;
                letter-spacing: 2px;
            }
        }

        @media print {
            body {
                background: white;
                padding: 0;
            }

            .container {
                background: white;
                box-shadow: none;
                max-width: none;
            }

            .controls, .action-buttons, .export-section {
                display: none;
            }

            .puzzle-card {
                page-break-inside: avoid;
                margin-bottom: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🔤🔢 Word & Number Sudoku Generator</h1>
        
        <div class="controls">
            <div class="control-group">
                <h3>🔧 Game Mode</h3>
                <div class="mode-buttons">
                    <button class="mode-btn active" data-mode="wordsudoku">🔤 Word Sudoku</button>
                    <button class="mode-btn" data-mode="numbersudoku">🔢 Number Sudoku</button>
                    <button class="mode-btn" data-mode="both">🎯 Both Puzzles</button>
                </div>
            </div>

            <div class="control-group">
                <h3>📐 Grid Settings</h3>
                <div class="form-group">
                    <label>Grid Size:</label>
                    <select id="gridSize">
                        <option value="4">4×4 (Easy - 4 letters/numbers)</option>
                        <option value="6" selected>6×6 (Medium - 6 letters/numbers)</option>
                        <option value="9">9×9 (Hard - 9 letters/numbers)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Number of Puzzles:</label>
                    <select id="puzzleCount">
                        <option value="1" selected>1 Puzzle Set</option>
                        <option value="2">2 Puzzle Sets</option>
                        <option value="3">3 Puzzle Sets</option>
                        <option value="4">4 Puzzle Sets</option>
                    </select>
                </div>
            </div>

            <div class="control-group word-sudoku-controls">
                <h3>🔤 Word Sudoku Settings</h3>
                <div class="form-group">
                    <label>Word Difficulty Level:</label>
                    <select id="wordDifficulty">
                        <option value="easy">Easy (40% filled)</option>
                        <option value="medium" selected>Medium (50% filled)</option>
                        <option value="hard">Hard (60% filled)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Custom Word (leave empty for random):</label>
                    <input type="text" id="customWord" class="word-input" placeholder="Enter a word..." maxlength="9">
                    <small style="color: #666; margin-top: 5px; display: block;">
                        💡 Tips: Enter words with unique letters for best results
                    </small>
                </div>
            </div>

            <div class="control-group number-sudoku-controls">
                <h3>🔢 Number Sudoku Settings</h3>
                <div class="form-group">
                    <label>Number Difficulty Level:</label>
                    <select id="numberDifficulty">
                        <option value="easy">Easy (40% filled)</option>
                        <option value="medium" selected>Medium (50% filled)</option>
                        <option value="hard">Hard (60% filled)</option>
                        <option value="expert">Expert (70% filled)</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Number Style:</label>
                    <select id="numberStyle">
                        <option value="standard" selected>Standard (1,2,3...)</option>
                        <option value="roman">Roman Numerals (I,II,III...)</option>
                        <option value="thai">Thai Numbers (๑,๒,๓...)</option>
                    </select>
                </div>
            </div>
        </div>

        <div class="action-buttons">
            <button class="btn btn-primary" onclick="generatePuzzles()">🎲 Generate Puzzles</button>
            <button class="btn btn-success" onclick="toggleSolutions()">👁️ Show/Hide Solutions</button>
            <button class="btn btn-warning" onclick="copyToClipboard()">📋 Copy to Clipboard</button>
        </div>

        <div class="export-section">
            <h3>📤 Export Options</h3>
            <div class="action-buttons">
                <button class="btn btn-info" onclick="exportToPDF()">📄 Export to PDF (A4)</button>
                <button class="btn btn-info" onclick="exportToExcel()">📊 Export to Excel</button>
                <button class="btn btn-info" onclick="printPuzzles()">🖨️ Print</button>
            </div>
        </div>

        <div id="puzzlesContainer" class="puzzles-container"></div>
    </div>

    <script>
        class NumberSudokuGenerator {
            constructor(size) {
                this.size = size;
                this.grid = [];
                this.solution = [];
            }

            generateNumberSudoku(difficulty) {
                this.grid = Array(this.size).fill().map(() => Array(this.size).fill(0));
                
                if (this.fillGrid()) {
                    this.solution = this.grid.map(row => [...row]);
                    this.createPuzzle(difficulty);
                    return true;
                }
                return false;
            }

            fillGrid() {
                return this.solve(0, 0);
            }

            solve(row, col) {
                if (row === this.size) return true;
                if (col === this.size) return this.solve(row + 1, 0);
                if (this.grid[row][col] !== 0) return this.solve(row, col + 1);

                const numbers = Array.from({length: this.size}, (_, i) => i + 1);
                const shuffledNumbers = this.shuffleArray(numbers);
                
                for (let num of shuffledNumbers) {
                    if (this.isValid(row, col, num)) {
                        this.grid[row][col] = num;
                        if (this.solve(row, col + 1)) return true;
                        this.grid[row][col] = 0;
                    }
                }
                return false;
            }

            isValid(row, col, num) {
                // Check row
                for (let c = 0; c < this.size; c++) {
                    if (this.grid[row][c] === num) return false;
                }
                
                // Check column
                for (let r = 0; r < this.size; r++) {
                    if (this.grid[r][col] === num) return false;
                }

                // Check box
                const boxSize = this.getBoxSize();
                const boxRow = Math.floor(row / boxSize.height) * boxSize.height;
                const boxCol = Math.floor(col / boxSize.width) * boxSize.width;
                
                for (let r = boxRow; r < boxRow + boxSize.height; r++) {
                    for (let c = boxCol; c < boxCol + boxSize.width; c++) {
                        if (this.grid[r][c] === num) return false;
                    }
                }

                return true;
            }

            getBoxSize() {
                switch (this.size) {
                    case 4: return { width: 2, height: 2 };
                    case 6: return { width: 3, height: 2 };
                    case 9: return { width: 3, height: 3 };
                    default: return { width: 2, height: 2 };
                }
            }

            createPuzzle(difficulty) {
                const difficultyLevels = {
                    easy: Math.floor(this.size * this.size * 0.4),
                    medium: Math.floor(this.size * this.size * 0.5),
                    hard: Math.floor(this.size * this.size * 0.6),
                    expert: Math.floor(this.size * this.size * 0.7)
                };

                const cellsToRemove = difficultyLevels[difficulty];
                const positions = [];
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        positions.push([r, c]);
                    }
                }

                const shuffledPositions = this.shuffleArray(positions);
                for (let i = 0; i < cellsToRemove; i++) {
                    const [r, c] = shuffledPositions[i];
                    this.grid[r][c] = 0;
                }
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }
        }

        class WordSudokuGenerator {
            constructor(size) {
                this.size = size;
                this.grid = [];
                this.solution = [];
                this.word = '';
                this.letters = [];
            }

            generateWordSudoku(word, difficulty) {
                this.word = word.toUpperCase();
                this.letters = [...new Set(this.word.split(''))];
                
                // Pad letters if needed
                while (this.letters.length < this.size) {
                    const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
                    const availableLetters = alphabet.split('').filter(l => !this.letters.includes(l));
                    if (availableLetters.length === 0) break;
                    this.letters.push(availableLetters[Math.floor(Math.random() * availableLetters.length)]);
                }
                
                this.letters = this.letters.slice(0, this.size);
                this.grid = Array(this.size).fill().map(() => Array(this.size).fill(''));
                
                if (this.fillGrid()) {
                    this.solution = this.grid.map(row => [...row]);
                    this.createPuzzle(difficulty);
                    return true;
                }
                return false;
            }

            fillGrid() {
                return this.solve(0, 0);
            }

            solve(row, col) {
                if (row === this.size) return true;
                if (col === this.size) return this.solve(row + 1, 0);
                if (this.grid[row][col] !== '') return this.solve(row, col + 1);

                const shuffledLetters = this.shuffleArray([...this.letters]);
                for (let letter of shuffledLetters) {
                    if (this.isValid(row, col, letter)) {
                        this.grid[row][col] = letter;
                        if (this.solve(row, col + 1)) return true;
                        this.grid[row][col] = '';
                    }
                }
                return false;
            }

            isValid(row, col, letter) {
                // Check row
                for (let c = 0; c < this.size; c++) {
                    if (this.grid[row][c] === letter) return false;
                }
                
                // Check column
                for (let r = 0; r < this.size; r++) {
                    if (this.grid[r][col] === letter) return false;
                }

                // Check box
                const boxSize = this.getBoxSize();
                const boxRow = Math.floor(row / boxSize.height) * boxSize.height;
                const boxCol = Math.floor(col / boxSize.width) * boxSize.width;
                
                for (let r = boxRow; r < boxRow + boxSize.height; r++) {
                    for (let c = boxCol; c < boxCol + boxSize.width; c++) {
                        if (this.grid[r][c] === letter) return false;
                    }
                }

                return true;
            }

            getBoxSize() {
                switch (this.size) {
                    case 4: return { width: 2, height: 2 };
                    case 6: return { width: 3, height: 2 };
                    case 9: return { width: 3, height: 3 };
                    default: return { width: 2, height: 2 };
                }
            }

            createPuzzle(difficulty) {
                const difficultyLevels = {
                    easy: Math.floor(this.size * this.size * 0.4),
                    medium: Math.floor(this.size * this.size * 0.5),
                    hard: Math.floor(this.size * this.size * 0.6)
                };

                const cellsToRemove = difficultyLevels[difficulty];
                const positions = [];
                for (let r = 0; r < this.size; r++) {
                    for (let c = 0; c < this.size; c++) {
                        positions.push([r, c]);
                    }
                }

                const shuffledPositions = this.shuffleArray(positions);
                for (let i = 0; i < cellsToRemove; i++) {
                    const [r, c] = shuffledPositions[i];
                    this.grid[r][c] = '';
                }
            }

            shuffleArray(array) {
                const shuffled = [...array];
                for (let i = shuffled.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
                }
                return shuffled;
            }

            getRandomWord(size, difficulty) {
                const wordLists = {
                    4: {
                        easy: ['LOVE', 'HOPE', 'PLAY', 'GAME', 'TIME', 'WIND', 'FIRE', 'MOON', 'STAR', 'BLUE'],
                        medium: ['JUMP', 'QUIZ', 'ZONE', 'COZY', 'FOXY', 'LAZY', 'MYTH', 'LYNX'],
                        hard: ['FLUX', 'JINX', 'QUAY', 'WAVY', 'ZEST', 'APEX', 'OXYZ']
                    },
                    6: {
                        easy: ['FRIEND', 'FAMILY', 'SCHOOL', 'GARDEN', 'SIMPLE', 'BRIGHT', 'ANIMAL', 'FLOWER'],
                        medium: ['PUZZLE', 'JOYFUL', 'WIZARD', 'FROZEN', 'QUIRKY', 'BLAZED', 'MONKEY'],
                        hard: ['ZEPHYR', 'FJORDS', 'QUARTZ', 'OXYGEN', 'JUXTAP', 'GLYPHS']
                    },
                    9: {
                        easy: ['WONDERFUL', 'BEAUTIFUL', 'FANTASTIC', 'ADVENTURE', 'CELEBRATE', 'KNOWLEDGE'],
                        medium: ['CLOCKWISE', 'LANDSCAPE', 'BIRTHDAYS', 'CHEMISTRY', 'FRAMEWORK', 'LANGUAGES'],
                        hard: ['BUZZKILLS', 'HIJACKING', 'PUZZLINGS', 'COMPLEXLY', 'QUIZZICAL', 'MYTHOLOGY']
                    }
                };

                const words = wordLists[size]?.[difficulty] || wordLists[6].medium;
                return words[Math.floor(Math.random() * words.length)];
            }
        }

        // Global variables
        let currentPuzzles = [];
        let showingSolutions = false;
        let currentMode = 'wordsudoku';

        // Number style converters
        const numberConverters = {
            standard: (num) => num.toString(),
            roman: (num) => {
                const romanNumerals = ['', 'I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'];
                return romanNumerals[num] || num.toString();
            },
            thai: (num) => {
                const thaiNumbers = ['', '๑', '๒', '๓', '๔', '๕', '๖', '๗', '๘', '๙'];
                return thaiNumbers[num] || num.toString();
            }
        };

        // Event listeners
        document.addEventListener('DOMContentLoaded', function() {
            // Mode button handlers
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    currentMode = this.dataset.mode;
                    updateControlVisibility();
                });
            });

            updateControlVisibility();
            generatePuzzles();
        });

        function updateControlVisibility() {
            const wordControls = document.querySelector('.word-sudoku-controls');
            const numberControls = document.querySelector('.number-sudoku-controls');

            wordControls.style.display = (currentMode === 'wordsudoku' || currentMode === 'both') ? 'block' : 'none';
            numberControls.style.display = (currentMode === 'numbersudoku' || currentMode === 'both') ? 'block' : 'none';
        }

        // Word meanings database
        const wordMeanings = {
            'LOVE': 'A strong feeling of affection',
            'HOPE': 'A feeling of expectation',
            'FRIEND': 'A person you know well and like',
            'PUZZLE': 'A game or problem to solve',
            'WIZARD': 'A person with magical powers',
            'WONDERFUL': 'Extremely good or beautiful',
            'BEAUTIFUL': 'Pleasing to look at',
            'CLOCKWISE': 'Moving in the direction of clock hands',
            'CHEMISTRY': 'The science of matter and its interactions',
            'ADVENTURE': 'An exciting or unusual experience'
        };

        function generatePuzzles() {
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const puzzleCount = parseInt(document.getElementById('puzzleCount').value);
            const wordDifficulty = document.getElementById('wordDifficulty').value;
            const numberDifficulty = document.getElementById('numberDifficulty').value;
            const customWord = document.getElementById('customWord').value.trim().toUpperCase();

            currentPuzzles = [];
            showingSolutions = false;

            for (let i = 0; i < puzzleCount; i++) {
                if (currentMode === 'wordsudoku' || currentMode === 'both') {
                    const generator = new WordSudokuGenerator(gridSize);
                    let word;
                    
                    if (customWord && customWord.length <= gridSize) {
                        word = customWord;
                    } else {
                        word = generator.getRandomWord(gridSize, wordDifficulty);
                    }

                    let attempts = 0;
                    while (attempts < 10) {
                        if (generator.generateWordSudoku(word, wordDifficulty)) {
                            currentPuzzles.push({
                                type: 'wordsudoku',
                                puzzle: generator.grid.map(row => [...row]),
                                solution: generator.solution,
                                word: word,
                                letters: generator.letters,
                                difficulty: wordDifficulty,
                                size: gridSize,
                                meaning: wordMeanings[word] || 'Complete the puzzle using these letters'
                            });
                            break;
                        }
                        attempts++;
                        word = generator.getRandomWord(gridSize, wordDifficulty);
                    }
                }

                if (currentMode === 'numbersudoku' || currentMode === 'both') {
                    const generator = new NumberSudokuGenerator(gridSize);
                    let attempts = 0;
                    while (attempts < 10) {
                        if (generator.generateNumberSudoku(numberDifficulty)) {
                            currentPuzzles.push({
                                type: 'numbersudoku',
                                puzzle: generator.grid.map(row => [...row]),
                                solution: generator.solution,
                                difficulty: numberDifficulty,
                                size: gridSize
                            });
                            break;
                        }
                        attempts++;
                    }
                }
            }

            displayPuzzles();
        }

        function displayPuzzles() {
            const container = document.getElementById('puzzlesContainer');
            container.innerHTML = '';

            currentPuzzles.forEach((puzzle, index) => {
                const puzzleCard = document.createElement('div');
                puzzleCard.className = 'puzzle-card';
                
                if (puzzle.type === 'wordsudoku') {
                    puzzleCard.innerHTML = createWordSudokuHTML(puzzle, index);
                } else if (puzzle.type === 'numbersudoku') {
                    puzzleCard.innerHTML = createNumberSudokuHTML(puzzle, index);
                }
                
                container.appendChild(puzzleCard);
            });
        }

        function createNumberSudokuHTML(puzzle, index) {
            const numberStyle = document.getElementById('numberStyle').value;
            const converter = numberConverters[numberStyle];
            
            const tableRows = puzzle.puzzle.map((row, r) => {
                const cells = row.map((cell, c) => {
                    let value = '';
                    if (showingSolutions) {
                        value = converter(puzzle.solution[r][c]);
                    } else if (cell !== 0) {
                        value = converter(cell);
                    }
                    
                    const cellClass = cell === 0 ? 
                        (showingSolutions ? 'solution-cell' : 'empty-cell') : 
                        'given-cell';
                    
                    return `<td class="${cellClass}">${value}</td>`;
                }).join('');
                return `<tr>${cells}</tr>`;
            }).join('');

            const numbersUsed = Array.from({length: puzzle.size}, (_, i) => i + 1);
            const numbersHTML = numbersUsed.map(num => 
                `<span class="number-item">${converter(num)}</span>`
            ).join('');

            const styleName = {
                standard: 'Standard Numbers',
                roman: 'Roman Numerals',
                thai: 'Thai Numbers'
            };

            return `
                <div class="puzzle-title">🔢 Number Sudoku #${index + 1}</div>
                <div class="puzzle-difficulty">Difficulty: ${puzzle.difficulty} | Size: ${puzzle.size}×${puzzle.size} | Style: ${styleName[numberStyle]}</div>
                
                <div class="number-display">
                    <div style="font-size: 1.5rem; font-weight: bold; color: #ff6b6b; margin-bottom: 5px;">
                        Number Sudoku Challenge
                    </div>
                    <div style="font-size: 1rem; color: #555;">
                        Fill each row, column, and box with unique numbers
                    </div>
                </div>
                
                <div class="puzzle-grid">
                    <table class="sudoku-table grid-${puzzle.size}x${puzzle.size}">
                        ${tableRows}
                    </table>
                </div>
                
                <div class="numbers-used">
                    <h4>Numbers to use:</h4>
                    <div class="number-list">${numbersHTML}</div>
                </div>
            `;
        }

        function createWordSudokuHTML(puzzle, index) {
            const tableRows = puzzle.puzzle.map((row, r) => {
                const cells = row.map((cell, c) => {
                    const value = showingSolutions ? puzzle.solution[r][c] : cell;
                    const cellClass = cell === '' ? 
                        (showingSolutions ? 'solution-cell' : 'empty-cell') : 
                        'given-cell';
                    
                    return `<td class="${cellClass}">${value}</td>`;
                }).join('');
                return `<tr>${cells}</tr>`;
            }).join('');

            const lettersHTML = puzzle.letters.map(letter => 
                `<span class="letter-item">${letter}</span>`
            ).join('');

            return `
                <div class="puzzle-title">🔤 Word Sudoku #${index + 1}</div>
                <div class="puzzle-difficulty">Difficulty: ${puzzle.difficulty} | Size: ${puzzle.size}×${puzzle.size}</div>
                
                <div class="word-display">
                    <div class="target-word">${puzzle.word}</div>
                    <div class="word-meaning">${puzzle.meaning}</div>
                </div>
                
                <div class="puzzle-grid">
                    <table class="sudoku-table grid-${puzzle.size}x${puzzle.size}">
                        ${tableRows}
                    </table>
                </div>
                
                <div class="letters-used">
                    <h4>Letters to use:</h4>
                    <div class="letter-list">${lettersHTML}</div>
                </div>
            `;
        }

        function getBoxSize(size) {
            switch (size) {
                case 4: return { width: 2, height: 2 };
                case 6: return { width: 3, height: 2 };
                case 9: return { width: 3, height: 3 };
                default: return { width: 2, height: 2 };
            }
        }

        function toggleSolutions() {
            showingSolutions = !showingSolutions;
            displayPuzzles();
        }

        function copyToClipboard() {
            const container = document.getElementById('puzzlesContainer');
            const range = document.createRange();
            range.selectNode(container);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
            document.execCommand('copy');
            window.getSelection().removeAllRanges();
            alert('Sudoku puzzles copied to clipboard!');
        }

        function printPuzzles() {
            window.print();
        }

        function exportToPDF() {
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF('p', 'mm', 'a4');
            
            doc.setFontSize(20);
            doc.text('Sudoku Collection', 105, 20, { align: 'center' });
            
            let yPosition = 35;
            const numberStyle = document.getElementById('numberStyle').value;
            const converter = numberConverters[numberStyle];
            
            currentPuzzles.forEach((puzzle, index) => {
                if (yPosition > 200) {
                    doc.addPage();
                    yPosition = 20;
                }
                
                // Title
                doc.setFontSize(16);
                const title = puzzle.type === 'wordsudoku' ? 
                    `Word Sudoku #${index + 1}` : 
                    `Number Sudoku #${index + 1}`;
                doc.text(title, 105, yPosition, { align: 'center' });
                yPosition += 8;
                
                // Word and meaning (only for word sudoku)
                if (puzzle.type === 'wordsudoku') {
                    doc.setFontSize(14);
                    doc.text(`Word: ${puzzle.word}`, 105, yPosition, { align: 'center' });
                    yPosition += 6;
                    doc.setFontSize(10);
                    doc.text(puzzle.meaning, 105, yPosition, { align: 'center' });
                    yPosition += 10;
                } else {
                    doc.setFontSize(12);
                    doc.text(`Difficulty: ${puzzle.difficulty}`, 105, yPosition, { align: 'center' });
                    yPosition += 10;
                }
                
                // Grid
                const cellSize = puzzle.size === 9 ? 15 : (puzzle.size === 6 ? 20 : 25);
                const startX = 105 - (puzzle.size * cellSize) / 2;
                const startY = yPosition;
                
                const boxSize = getBoxSize(puzzle.size);
                
                for (let r = 0; r < puzzle.size; r++) {
                    for (let c = 0; c < puzzle.size; c++) {
                        const x = startX + c * cellSize;
                        const y = startY + r * cellSize;
                        
                        // Draw cell
                        doc.rect(x, y, cellSize, cellSize);
                        
                        // Add thicker lines for boxes
                        if ((c + 1) % boxSize.width === 0 && c < puzzle.size - 1) {
                            doc.setLineWidth(1);
                            doc.line(x + cellSize, y, x + cellSize, y + cellSize);
                            doc.setLineWidth(0.2);
                        }
                        if ((r + 1) % boxSize.height === 0 && r < puzzle.size - 1) {
                            doc.setLineWidth(1);
                            doc.line(x, y + cellSize, x + cellSize, y + cellSize);
                            doc.setLineWidth(0.2);
                        }
                        
                        // Add content
                        let cellValue = '';
                        if (puzzle.type === 'wordsudoku') {
                            cellValue = puzzle.puzzle[r][c];
                        } else {
                            cellValue = puzzle.puzzle[r][c] === 0 ? '' : converter(puzzle.puzzle[r][c]);
                        }
                        
                        if (cellValue) {
                            doc.setFontSize(12);
                            doc.text(cellValue, x + cellSize/2, y + cellSize/2 + 2, { align: 'center' });
                        }
                    }
                }
                
                yPosition += puzzle.size * cellSize + 15;
                
                // Add items to use
                if (puzzle.type === 'wordsudoku') {
                    doc.setFontSize(10);
                    doc.text(`Letters to use: ${puzzle.letters.join(', ')}`, 105, yPosition, { align: 'center' });
                } else {
                    const numbers = Array.from({length: puzzle.size}, (_, i) => converter(i + 1));
                    doc.text(`Numbers to use: ${numbers.join(', ')}`, 105, yPosition, { align: 'center' });
                }
                yPosition += 10;
                
                // Add solution if showing
                if (showingSolutions) {
                    doc.text('Solution:', 105, yPosition, { align: 'center' });
                    yPosition += 8;
                    
                    for (let r = 0; r < puzzle.size; r++) {
                        for (let c = 0; c < puzzle.size; c++) {
                            const x = startX + c * cellSize;
                            const y = yPosition + r * cellSize;
                            
                            doc.rect(x, y, cellSize, cellSize);
                            doc.setTextColor(255, 0, 0); // Red for solution
                            doc.setFontSize(12);
                            
                            let solutionValue = '';
                            if (puzzle.type === 'wordsudoku') {
                                solutionValue = puzzle.solution[r][c];
                            } else {
                                solutionValue = converter(puzzle.solution[r][c]);
                            }
                            
                            doc.text(solutionValue, x + cellSize/2, y + cellSize/2 + 2, { align: 'center' });
                            doc.setTextColor(0, 0, 0); // Reset to black
                        }
                    }
                    
                    yPosition += puzzle.size * cellSize + 15;
                }
                
                yPosition += 20;
            });
            
            doc.save('sudoku-puzzles.pdf');
        }

        function exportToExcel() {
            const wb = XLSX.utils.book_new();
            const numberStyle = document.getElementById('numberStyle').value;
            const converter = numberConverters[numberStyle];
            
            currentPuzzles.forEach((puzzle, index) => {
                const wsData = [];
                
                if (puzzle.type === 'wordsudoku') {
                    wsData.push([`Word Sudoku #${index + 1}`]);
                    wsData.push([`Word: ${puzzle.word}`]);
                    wsData.push([`Meaning: ${puzzle.meaning}`]);
                    wsData.push([`Difficulty: ${puzzle.difficulty}`]);
                    wsData.push([]);
                    wsData.push(['Puzzle:']);
                    
                    // Add puzzle grid
                    for (let r = 0; r < puzzle.size; r++) {
                        const row = [];
                        for (let c = 0; c < puzzle.size; c++) {
                            row.push(puzzle.puzzle[r][c] || '');
                        }
                        wsData.push(row);
                    }
                    
                    wsData.push([]);
                    wsData.push(['Solution:']);
                    
                    // Add solution grid
                    for (let r = 0; r < puzzle.size; r++) {
                        const row = [];
                        for (let c = 0; c < puzzle.size; c++) {
                            row.push(puzzle.solution[r][c]);
                        }
                        wsData.push(row);
                    }
                    
                    wsData.push([]);
                    wsData.push([`Letters to use: ${puzzle.letters.join(', ')}`]);
                    
                    const ws = XLSX.utils.aoa_to_sheet(wsData);
                    XLSX.utils.book_append_sheet(wb, ws, `WordSudoku${index + 1}`);
                    
                } else if (puzzle.type === 'numbersudoku') {
                    wsData.push([`Number Sudoku #${index + 1}`]);
                    wsData.push([`Difficulty: ${puzzle.difficulty}`]);
                    wsData.push([`Style: ${numberStyle}`]);
                    wsData.push([]);
                    wsData.push(['Puzzle:']);
                    
                    // Add puzzle grid
                    for (let r = 0; r < puzzle.size; r++) {
                        const row = [];
                        for (let c = 0; c < puzzle.size; c++) {
                            row.push(puzzle.puzzle[r][c] === 0 ? '' : converter(puzzle.puzzle[r][c]));
                        }
                        wsData.push(row);
                    }
                    
                    wsData.push([]);
                    wsData.push(['Solution:']);
                    
                    // Add solution grid
                    for (let r = 0; r < puzzle.size; r++) {
                        const row = [];
                        for (let c = 0; c < puzzle.size; c++) {
                            row.push(converter(puzzle.solution[r][c]));
                        }
                        wsData.push(row);
                    }
                    
                    wsData.push([]);
                    const numbers = Array.from({length: puzzle.size}, (_, i) => converter(i + 1));
                    wsData.push([`Numbers to use: ${numbers.join(', ')}`]);
                    
                    const ws = XLSX.utils.aoa_to_sheet(wsData);
                    XLSX.utils.book_append_sheet(wb, ws, `NumberSudoku${index + 1}`);
                }
            });
            
            XLSX.writeFile(wb, 'sudoku-puzzles.xlsx');
        }

        // Initialize with demo puzzles
        document.addEventListener('DOMContentLoaded', function() {
            generatePuzzles();
        });
    </script>
</body>
</html>